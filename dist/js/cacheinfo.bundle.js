(()=>{"use strict";const e=new Proxy({},{get:(e,t)=>("ARTICLE_REPO"===t&&(console.log("[const.ts Proxy] Getting ARTICLE_REPO"),console.log("[const.ts Proxy] window.ENV:",window.ENV),console.log("[const.ts Proxy] window.ENV?.ARTICLE_REPO:",window.ENV?.ARTICLE_REPO)),"DEFAULT_CHAIN_ID"===t?parseInt(window.ENV?.BC_NETWORK_ID||"1"):"CONTRACT_ADDRESS"===t?window.ENV?.MANAGER_CA||"":window.ENV?.[t]||{HEADER_TITLE:"BizenDAO",DEFAULT_SYMBOL:"BIZEN",DONATE_SYMBOL:"dBIZ",API_BASE_URL:"",BOT_API_URL:"",ARTICLE_REPO:"",METABUILDER_URL:"",BC_NETWORK_ID:"1",BC_NETWORK_NAME:"Ethereum Mainnet",RPC_URL:"",MANAGER_CA:"",MEMBERSCARD_CA:"",SOUL_BINDER_ROLE_ID:"1",TBA_SALT:"0",DISCORD_HOLDER_ROLL_ID:"",DISCORD_HOLDER_ROLL_NAME:"Holder",CRYPTO_SECRET:"",SRC_VERSION:"1.0.0"}[t]||"")}),t=new class{dbName="bizenDAO_rpc_cache";version=1;db=null;metrics={hits:0,misses:0,evictions:0,errors:0};constructor(){this.initDB()}async initDB(){return new Promise(((e,t)=>{const r=indexedDB.open(this.dbName,this.version);r.onerror=()=>{console.error("Failed to open IndexedDB:",r.error),t(r.error)},r.onsuccess=()=>{this.db=r.result,e()},r.onupgradeneeded=e=>{const t=e.target.result;if(!t.objectStoreNames.contains("cache")){const e=t.createObjectStore("cache",{keyPath:"key"});e.createIndex("timestamp","timestamp",{unique:!1}),e.createIndex("expiry","expiry",{unique:!1}),e.createIndex("category","category",{unique:!1})}t.objectStoreNames.contains("gallery_cache")||t.createObjectStore("gallery_cache",{keyPath:"creator"}).createIndex("lastUpdated","lastUpdated",{unique:!1})}}))}generateCacheKey(t,r,n){const s=e.BC_NETWORK_ID,i=this.sanitizeParams(r),a=JSON.stringify(i||{});return n?`${s}:${n}:${t}:${a}`:`${s}:${t}:${a}`}sanitizeParams(e){if(null==e)return e;if("bigint"==typeof e)return e.toString();if(Array.isArray(e))return e.map((e=>this.sanitizeParams(e)));if("object"==typeof e){const t={};for(const r in e)t[r]=this.sanitizeParams(e[r]);return t}return e}isExpired(e){return null!==e.expiry&&Date.now()>e.expiry}async get(e){return this.db||await this.initDB(),new Promise((t=>{try{const r=this.db.transaction(["cache"],"readonly").objectStore("cache").get(e);r.onsuccess=()=>{const n=r.result;return n?this.isExpired(n)?(this.metrics.misses++,this.delete(e),void t(null)):(this.metrics.hits++,void t(n.value)):(this.metrics.misses++,void t(null))},r.onerror=()=>{this.metrics.errors++,console.error("Cache get error:",r.error),t(null)}}catch(e){this.metrics.errors++,console.error("Cache get error:",e),t(null)}}))}async set(e,t,r,n="general"){this.db||await this.initDB();const s=null===r?null:r?Date.now()+r:null,i=new Blob([JSON.stringify(t)]).size,a={key:e,value:t,timestamp:Date.now(),expiry:s,category:n,size:i};return new Promise(((e,t)=>{try{const r=this.db.transaction(["cache"],"readwrite").objectStore("cache").put(a);r.onsuccess=()=>e(),r.onerror=()=>{this.metrics.errors++,console.error("Cache set error:",r.error),t(r.error)}}catch(e){this.metrics.errors++,console.error("Cache set error:",e),t(e)}}))}async delete(e){return this.db||await this.initDB(),new Promise(((t,r)=>{try{const n=this.db.transaction(["cache"],"readwrite").objectStore("cache").delete(e);n.onsuccess=()=>{this.metrics.evictions++,t()},n.onerror=()=>r(n.error)}catch(e){r(e)}}))}async deletePattern(e){return this.db||await this.initDB(),new Promise(((t,r)=>{try{const n=this.db.transaction(["cache"],"readwrite").objectStore("cache").openCursor();n.onsuccess=()=>{const r=n.result;if(r){const t=r.value.key;this.matchPattern(t,e)&&(r.delete(),this.metrics.evictions++),r.continue()}else t()},n.onerror=()=>r(n.error)}catch(e){r(e)}}))}matchPattern(e,t){return new RegExp(t.replace(/\*/g,".*")).test(e)}async setGalleryCache(e,t,r){return this.db||await this.initDB(),new Promise(((e,r)=>{try{const n=this.db.transaction(["gallery_cache"],"readwrite").objectStore("gallery_cache").put(t);n.onsuccess=()=>e(),n.onerror=()=>r(n.error)}catch(e){r(e)}}))}async getGalleryCache(e){return this.db||await this.initDB(),new Promise((t=>{try{const r=this.db.transaction(["gallery_cache"],"readonly").objectStore("gallery_cache").get(e);r.onsuccess=()=>{const n=r.result;if(n)return Date.now()-n.lastUpdated>36e5?(this.deleteGalleryCache(e),void t(null)):void t(n);t(null)},r.onerror=()=>t(null)}catch(e){t(null)}}))}async deleteGalleryCache(e){return this.db||await this.initDB(),new Promise(((t,r)=>{try{const n=this.db.transaction(["gallery_cache"],"readwrite").objectStore("gallery_cache").delete(e);n.onsuccess=()=>t(),n.onerror=()=>r(n.error)}catch(e){r(e)}}))}async clearAll(){return this.db||await this.initDB(),new Promise(((e,t)=>{try{const r=this.db.transaction(["cache","gallery_cache"],"readwrite"),n=r.objectStore("cache"),s=r.objectStore("gallery_cache");n.clear(),s.clear(),r.oncomplete=()=>{this.metrics={hits:0,misses:0,evictions:0,errors:0},e()},r.onerror=()=>t(r.error)}catch(e){t(e)}}))}getMetrics(){const e=this.metrics.hits+this.metrics.misses,t=e>0?this.metrics.hits/e*100:0;return{...this.metrics,hitRate:t.toFixed(2)+"%",totalRequests:e}}async getStorageInfo(){if("storage"in navigator&&"estimate"in navigator.storage){const e=await navigator.storage.estimate();return{usage:e.usage||0,quota:e.quota||0,percentage:(e.usage||0)/(e.quota||1)*100}}return null}async handleTokenBurn(e,t){await this.deletePattern(`*tokenURI.*"tokenId":"${e}"*`),await this.deletePattern(`*ownerOf.*"tokenId":"${e}"*`),await this.deletePattern(`*tokenLocked.*"tokenId":"${e}"*`),await this.deletePattern("*totalSupply*"),await this.deletePattern("*TokenCount*"),await this.deletePattern(`*creatorTokens.*"creator":"${t}"*`),await this.deleteGalleryCache(t)}};async function r(){await async function(){const e=t.getMetrics(),r=document.getElementById("metrics");var n;r&&(r.innerHTML=`\n      <div class="metric-card">\n        <div class="metric-value ${n=parseFloat(e.hitRate),n>=80?"status-good":n>=50?"status-warning":"status-danger"}">${e.hitRate}</div>\n        <div class="metric-label">Hit Rate</div>\n      </div>\n      <div class="metric-card">\n        <div class="metric-value">${e.totalRequests}</div>\n        <div class="metric-label">Total Requests</div>\n      </div>\n      <div class="metric-card">\n        <div class="metric-value">${e.hits}</div>\n        <div class="metric-label">Cache Hits</div>\n      </div>\n      <div class="metric-card">\n        <div class="metric-value">${e.misses}</div>\n        <div class="metric-label">Cache Misses</div>\n      </div>\n    `)}(),await async function(){const e=await t.getStorageInfo();if(e){const t=(e.usage/1024/1024).toFixed(2),r=(e.quota/1024/1024).toFixed(2),n=e.percentage.toFixed(1),s=document.getElementById("storage-progress"),i=document.getElementById("storage-text");s&&(s.style.width=`${n}%`),i&&(i.textContent=`${t} MB / ${r} MB (${n}%)`)}}(),await async function(){const e=await async function(){return new Promise((e=>{const t=indexedDB.open("bizenDAO_rpc_cache",1);t.onsuccess=()=>{const r=t.result.transaction(["cache"],"readonly").objectStore("cache").getAll();r.onsuccess=()=>{const t=r.result;e(t)},r.onerror=()=>{e([])}},t.onerror=()=>{e([])}}))}(),t=document.getElementById("cache-entries");if(!t)return;if(0===e.length)return void(t.innerHTML="<p>No cache entries found.</p>");const r=e.sort(((e,t)=>t.timestamp-e.timestamp)).slice(0,100);t.innerHTML=r.map((e=>{const t=new Date(e.timestamp).toLocaleString(),r=e.expiry?new Date(e.expiry).toLocaleString():"Never",n=(e.size/1024).toFixed(2);return`\n      <div class="cache-entry">\n        <strong>Key:</strong> ${e.key}<br>\n        <strong>Category:</strong> ${e.category}<br>\n        <strong>Size:</strong> ${n} KB<br>\n        <strong>Cached:</strong> ${t}<br>\n        <strong>Expires:</strong> ${r}\n      </div>\n    `})).join("")}()}async function n(){confirm("Are you sure you want to clear all cache? This action cannot be undone.")&&(await t.clearAll(),alert("Cache cleared successfully!"),await r())}document.addEventListener("DOMContentLoaded",(()=>{const e=document.getElementById("refresh-btn"),t=document.getElementById("clear-cache-btn");e&&e.addEventListener("click",r),t&&t.addEventListener("click",n),r(),setInterval(r,5e3)}))})();